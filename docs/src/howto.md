```@meta
CurrentModule = Hecke
DocTestSetup = Hecke.doctestsetup()
```
# Getting Started
The guides provided here are for users that would like to rapidly start using Hecke.jl in their workflow. We also provide [tutorials](tutorials/index.md), which go into more depth for particular topics. For users looking for specific information regarding what exactly is provided by Hecke, we recommend looking in the [manual](manual/index.md).

## Define an order in a number field

Usually, to create an order, one starts with a number field (respectively a defining polynomial):

```jldoctest 1
julia> Qx, x = QQ[:x];

julia> K, a = number_field(x^2 - 5, :a);
```

The number field is ``K = \mathbb{Q}(\alpha)``, where ``\alpha`` is a root of ``f = x^2 - 10``.
Since the polynomial ``f`` is integral, the ring ``\mathbb{Z}[\alpha]`` generated by ``\alpha`` is an order of ``K``.
This so-called *equation order* can be defined as follows:

```jldoctest 1
julia> E = equation_order(K)
Order
  of number field with defining polynomial x^2 - 5
    over rational field
with Z-basis [1, a]
```

The maximal order can be computed as:
```jldoctest 1
julia> maximal_order(K)
Maximal order
  of number field with defining polynomial x^2 - 5
    over rational field
with Z-basis [1, 1//2*a + 1//2]
```

We can also compute the order generated by a finite set of elements, that is,
the smallest order of ``K`` containing all elements:

```jldoctest 1
julia> order(K, [15*a, 10*a + 10])
Order
  of number field with defining polynomial x^2 - 5
    over rational field
with Z-basis [1, 5*a]
```

We can also supply a matrix containing the coordinates of a basis (as rows):
```jldoctest 1
julia> order(K, ZZ[1 0; 0 5])
Order
  of number field with defining polynomial x^2 - 5
    over rational field
with Z-basis [1, 5*a]
```

## Decompose a prime in the ring of integers

```jldoctest 1
julia> Qx, x = QQ[:x];

julia> K, a = number_field(x^2 - 5, :a);

julia> OK = ring_of_integers(K);
```

We decompose the ideals generated by ``5``, ``7`` and ``11``:

```jldoctest 1
julia> prime_decomposition(OK, 5)
1-element Vector{Tuple{AbsSimpleNumFieldOrderIdeal, Int64}}:
 (<5, a>, 2)

julia> prime_decomposition(OK, 7)
1-element Vector{Tuple{AbsSimpleNumFieldOrderIdeal, Int64}}:
 (<7>, 1)

julia> prime_decomposition(OK, 11)
2-element Vector{Tuple{AbsSimpleNumFieldOrderIdeal, Int64}}:
 (<11, a + 4>, 1)
 (<11, a + 7>, 1)
```

It is also possible to directly determine the decomposition type:
```jldoctest 1
julia> prime_decomposition_type(OK, 5)
1-element Vector{Tuple{Int64, Int64}}:
 (1, 2)

julia> prime_decomposition_type(OK, 7)
1-element Vector{Tuple{Int64, Int64}}:
 (2, 1)

julia> prime_decomposition_type(OK, 11)
2-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (1, 1)
```

We can also determine the prime ideals above prime numbers in non-maximal orders:

```jldoctest 1
julia> R = equation_order(K)
Order
  of number field with defining polynomial x^2 - 5
    over rational field
with Z-basis [1, a]

julia> prime_ideals_over(R, 2)
1-element Vector{AbsSimpleNumFieldOrderIdeal}:
 <2, a + 1>
```

## Test if an ideal is principal

```jldoctest 1; filter = r"true,*"
julia> Qx, x = QQ[:x];

julia> K, a = number_field(x^2 - 10, :a);

julia> OK = ring_of_integers(K);

julia> P, = prime_ideals_over(OK, 2);

julia> basis_matrix(P)
[2   0]
[0   1]

julia> is_principal(P)
false

julia> is_principal(P^2)
true

julia> is_principal_with_data(P^2)
(true, 2)
```

## Construct a residue field

```jldoctest 1
julia> Qx, x = QQ[:x];

julia> K, a = number_field(x^2 - 10, :a);

julia> OK = ring_of_integers(K);

julia> P, = prime_ideals_over(OK, 2);

julia> Fp, mFp = residue_field(OK, P)
(Prime field of characteristic 2, Map: OK -> Fp)

julia> [mFp(x) for x = basis(OK)]
2-element Vector{FqFieldElem}:
 1
 0
```

## Reduce polynomials over number fields modulo a prime ideal

Given a polynomial ``f \in K[x]`` and a prime ideal ``\mathfrak p`` of ``\mathcal O_K``,
we want to determine the reduction ``\bar f \in F[x]``, where ``F = \mathcal O_K/\mathfrak p``
is the residue field.
Concretely, we want to reduce the polynomial
```math
f = x^3 + (1 + ζ_7 + ζ_7^2)x^2 + (23 + 55ζ_7^5)x + (ζ_7 + 77)/2
```
defined over ``\mathbb{Q}(\zeta_7)``.
We begin by defining the cyclotomic field and the polynomial.

```jldoctest 1
julia> K, ζ = cyclotomic_field(7);

julia> Kx, x = K[:x];

julia> f = x^3 + (1 + ζ + ζ^2)*x^2 + (23 + 55ζ^5)x + (ζ + 77)//2
x^3 + (z_7^2 + z_7 + 1)*x^2 + (55*z_7^5 + 23)*x + 1//2*z_7 + 77//2
```

Next we determine the ring of integers ``\mathcal O_K`` and a prime ideal
``\mathfrak p`` lying above the prime ``p = 29``.

```jldoctest 1
julia> OK = maximal_order(K);

julia> p = 29;

julia> frakp = prime_decomposition(OK, p)[1][1]
Ideal of maximal order of cyclotomic field of order 7
  of norm 29
  of minimum 29
with 29-normal generators [29, z_7 + 22]
```

We can now determine the residue field ``F = \mathcal{O}_K/\mathfrak p`` and
the canonical map ``\mathcal O_K \to F``.

```jldoctest 1
julia> F, reduction_map_OK = residue_field(OK, frakp);

julia> F
Prime field of characteristic 29

julia> reduction_map_OK
Map
  from maximal order of cyclotomic field of order 7
  to prime field of characteristic 29
```

Note that the reduction map has domain ``\mathcal O_K`` and thus cannot be applied
to elements of ``K``. We can extend it to the set of ``\mathfrak p``-integral elements
by invoking the `extend` function.
Note that the domain of the extended map will be the whole ``K``, but the map
will throw an error when applied to elements which are not ``\mathfrak p``-integral.

```jldoctest 1
julia> reduction_map_extended = extend(reduction_map_OK, K)
Map
  from cyclotomic field of order 7
  to prime field of characteristic 29

julia> reduction_map_extended(K(1//3))
10

julia> reduction_map_extended(K(1//29))
ERROR: Element not p-integral
[...]
```

Finally we can reduce ``f`` modulo ``\mathfrak p``, which we obtain by applying
the reduction map to the coefficients.

```jldoctest 1
julia> fbar = map_coefficients(reduction_map_extended, f)
x^3 + 28*x^2 + 4*x + 13

julia> base_ring(fbar) === F
true
```
